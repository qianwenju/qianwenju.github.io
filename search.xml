<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>5-RNAseq--无重复差异基因分析（edgeR包的使用）</title>
    <url>/2020/03/19/5-RNAseq--%E6%97%A0%E9%87%8D%E5%A4%8D%E5%B7%AE%E5%BC%82%E5%9F%BA%E5%9B%A0%E5%88%86%E6%9E%90%EF%BC%88edgeR%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%89/</url>
    <content><![CDATA[<p>######1）简介<br>edgeR作用对象是count文件，rows 代表基因，行代表文库，count代表的是比对到每个基因的reads数目。它主要关注的是差异表达分析，而不是定量基因表达水平。</p>
<p>edgeR works on a table of integer read counts, with rows corresponding to genes and columns to independent libraries. The counts represent the total number of reads aligning to each gene (or other genomic locus).edgeR is concerned with diﬀerential expression analysis rather than with the quantiﬁcation of expression levels. It is concerned with relative changes in expression levels between conditions,but not directly with estimating absolute expression levels.</p>
<p>edgeR作用的是真实的比对统计，因此不建议用预测的转录本</p>
<p>Note that edgeR is designed to work with actual read counts. We not recommend that predicted transcript abundances are input the edgeR in place of actual counts.</p>
<p>归一化原因：</p>
<blockquote>
<p>技术原因影响差异表达分析：<br>1）Sequencing depth：统计测序深度(即代表的是library size)；<br>2）RNA composition：个别异常高表达基因导致其它基因采样不足<br>3）GC content： sample-speciﬁc eﬀects for GC-content can be detected<br>4）sample-speciﬁc eﬀects for gene length have been detected</p>
</blockquote>
<p><strong>注意：edgeR必须是原始表达量，而不能是rpkm等矫正过的。</strong><br>Note that normalization in edgeR is model-based, and the original read counts are not themselves transformed. This means that users should not transform the read counts in any way before inputing them to edgeR. For example, users should not enter RPKM or FPKM values to edgeR in place of read counts. Such quantities will prevent edgeR from correctly estimating the mean-variance relationship in the data, which is a crucial to the statistical strategies underlying edgeR.Similarly, users should not add artiﬁcial values to the counts before inputing them to edgeR.<br>个人是不太推荐没有重复的差异表达分析，因为毕竟统计学上的p值是为了证明两个样本的差异是真实存在而不是抽样误差导致的，<br>因此每当别人提问的时候, 我个人的建议就是定性看看倍数变化吧. 但是如果真的强行要算p值, 其实也不是不行, edgeR就是一种选择.</p>
<h5 id="2-、首先安装edgeR-包"><a href="#2-、首先安装edgeR-包" class="headerlink" title="2)、首先安装edgeR 包"></a>2)、首先安装edgeR 包</h5><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#如果没有安装BiocMaRnager则先安装BiocManager，之后通过BiocManager安装edgeR包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!requireNamespace(<span class="string">"BiocManager"</span>, quietly = <span class="keyword">TRUE</span>))</span><br><span class="line">    <span class="keyword">install</span>.packages(<span class="string">"BiocManager"</span>)</span><br><span class="line"></span><br><span class="line">BiocManager::<span class="keyword">install</span>(<span class="string">"edgeR"</span>)</span><br></pre></td></tr></table></figure>
<p>安装结束之后开始处理文件</p>
<h5 id="3）矩阵构建及差异分析"><a href="#3）矩阵构建及差异分析" class="headerlink" title="3）矩阵构建及差异分析"></a>3）矩阵构建及差异分析</h5><p>需要构建2个矩阵：1、表达矩阵；2、分组矩阵( 实验设计)；</p>
<h6 id="3-1-表达矩阵"><a href="#3-1-表达矩阵" class="headerlink" title="3.1 表达矩阵"></a>3.1 表达矩阵</h6><p>3.11 读取文件</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"># 首先读取counts文件之后查看count文件前<span class="number">6</span>行</span><br><span class="line">&gt; rawdata &lt;- read.csv(file = <span class="string">"C://Users/My/Desktop/diff_name"</span>,header = T,<span class="built_in">string</span>sAsFactors = F)</span><br><span class="line"># 查看读取的diff_name文件</span><br><span class="line">&gt; head(rawdata)</span><br><span class="line">  X    ensembl_gene_id               gene_id control_W55 test_K54 external_gene_name</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> ENSMUSG00000000001  ENSMUSG00000000001<span class="number">.4</span>           <span class="number">7</span>       <span class="number">11</span>              Gnai3</span><br><span class="line"><span class="number">2</span> <span class="number">2</span> ENSMUSG00000000003 ENSMUSG00000000003<span class="number">.15</span>           <span class="number">0</span>        <span class="number">0</span>               Pbsn</span><br><span class="line"><span class="number">3</span> <span class="number">3</span> ENSMUSG00000000028 ENSMUSG00000000028<span class="number">.15</span>           <span class="number">1</span>        <span class="number">0</span>              Cdc45</span><br><span class="line"><span class="number">4</span> <span class="number">4</span> ENSMUSG00000000031 ENSMUSG00000000031<span class="number">.16</span>           <span class="number">0</span>        <span class="number">2</span>                H19</span><br><span class="line"><span class="number">5</span> <span class="number">5</span> ENSMUSG00000000037 ENSMUSG00000000037<span class="number">.17</span>           <span class="number">0</span>        <span class="number">0</span>              Scml2</span><br><span class="line"><span class="number">6</span> <span class="number">6</span> ENSMUSG00000000049 ENSMUSG00000000049<span class="number">.11</span>          <span class="number">54</span>       <span class="number">33</span>               Apoh</span><br></pre></td></tr></table></figure>
<p>读取完数据之后我们先预处理一下数据，比如我只想要ensembl_gene_id、control_w55、tese_k54、external_gene_name这几列，并调整一下顺序。</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">&gt; swap_rawdata &lt;- cbind(rawdata$ensembl_gene_id,rawdata$external_gene_name,rawdata$control_W55,rawdata$test_K54)</span><br><span class="line">&gt; head(swap_rawdata)</span><br><span class="line">     [,<span class="number">1</span>]                 [,<span class="number">2</span>]    [,<span class="number">3</span>] [,<span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>,] <span class="string">"ENSMUSG00000000001"</span> <span class="string">"Gnai3"</span> <span class="string">"7"</span>  <span class="string">"11"</span></span><br><span class="line">[<span class="number">2</span>,] <span class="string">"ENSMUSG00000000003"</span> <span class="string">"Pbsn"</span>  <span class="string">"0"</span>  <span class="string">"0"</span> </span><br><span class="line">[<span class="number">3</span>,] <span class="string">"ENSMUSG00000000028"</span> <span class="string">"Cdc45"</span> <span class="string">"1"</span>  <span class="string">"0"</span> </span><br><span class="line">[<span class="number">4</span>,] <span class="string">"ENSMUSG00000000031"</span> <span class="string">"H19"</span>   <span class="string">"0"</span>  <span class="string">"2"</span> </span><br><span class="line">[<span class="number">5</span>,] <span class="string">"ENSMUSG00000000037"</span> <span class="string">"Scml2"</span> <span class="string">"0"</span>  <span class="string">"0"</span> </span><br><span class="line">[<span class="number">6</span>,] <span class="string">"ENSMUSG00000000049"</span> <span class="string">"Apoh"</span>  <span class="string">"54"</span> <span class="string">"33"</span></span><br><span class="line"># 得到的这个swap_rawdata是一个matrix，如果想要让其变为data frame</span><br><span class="line">&gt; swap_rawdata &lt;- data.frame(swap_rawdata)</span><br><span class="line"># 查看一下是否转化成功</span><br><span class="line">&gt; head(swap_rawdata)</span><br><span class="line">     ensembl_gene_id external_gene_name control_W55 test_K54</span><br><span class="line"><span class="number">1</span> ENSMUSG00000000001              Gnai3           <span class="number">7</span>       <span class="number">11</span></span><br><span class="line"><span class="number">2</span> ENSMUSG00000000003               Pbsn           <span class="number">0</span>        <span class="number">0</span></span><br><span class="line"><span class="number">3</span> ENSMUSG00000000028              Cdc45           <span class="number">1</span>        <span class="number">0</span></span><br><span class="line"><span class="number">4</span> ENSMUSG00000000031                H19           <span class="number">0</span>        <span class="number">2</span></span><br><span class="line"><span class="number">5</span> ENSMUSG00000000037              Scml2           <span class="number">0</span>        <span class="number">0</span></span><br><span class="line"><span class="number">6</span> ENSMUSG00000000049               Apoh          <span class="number">54</span>       <span class="number">33</span></span><br><span class="line"># 转化完转化先存一份csv文件在电脑里，便于之后用电脑查看</span><br><span class="line">&gt; write.csv(x = swap_rawdata,file = <span class="string">"C://Users/My/Desktop/swap_rawdata.csv"</span>)</span><br><span class="line"># 存完之后直接从电脑导入你刚存的文件，这样做可以避免出现numeric数据框变成factor形式</span><br><span class="line">&gt; swap_rawdata &lt;- read.table(<span class="string">"swap_rawdata.csv"</span>,header = T,sep = <span class="string">","</span>)</span><br><span class="line"># 查看</span><br><span class="line">&gt; head(swap_rawdata)</span><br><span class="line">  X    ensembl_gene_id external_gene_name control_W55 test_K54</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> ENSMUSG00000000001              Gnai3           <span class="number">7</span>       <span class="number">11</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> ENSMUSG00000000003               Pbsn           <span class="number">0</span>        <span class="number">0</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span> ENSMUSG00000000028              Cdc45           <span class="number">1</span>        <span class="number">0</span></span><br><span class="line"><span class="number">4</span> <span class="number">4</span> ENSMUSG00000000031                H19           <span class="number">0</span>        <span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="number">5</span> ENSMUSG00000000037              Scml2           <span class="number">0</span>        <span class="number">0</span></span><br><span class="line"><span class="number">6</span> <span class="number">6</span> ENSMUSG00000000049               Apoh          <span class="number">54</span>       <span class="number">33</span></span><br><span class="line">&gt; data.class(swap_rawdata[<span class="number">1</span>,<span class="number">1</span>])</span><br></pre></td></tr></table></figure>


<h6 id="3-2-接着构建DGEList对象"><a href="#3-2-接着构建DGEList对象" class="headerlink" title="3.2 接着构建DGEList对象"></a>3.2 接着构建DGEList对象</h6><p>这里因为已经有rawdata的count文件，因此直接用DGEList()函数就行了，否则要用readDGE()函数</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先载入edgeR 包</span></span><br><span class="line">&gt; library(edgeR)</span><br><span class="line"><span class="comment"># 构建DGEList</span></span><br><span class="line">&gt;<span class="built_in"> group </span>&lt;- 1:2</span><br><span class="line">&gt; y &lt;- DGEList(counts = swap_rawdata[,4:5],genes = swap_rawdata[,2:3],group = group)</span><br><span class="line"><span class="comment"># 查看构建完y的信息</span></span><br><span class="line">&gt; y</span><br></pre></td></tr></table></figure>
<p>查看构建DGElist的运行结果:</p>
<p> DGEList对象主要有三部分：</p>
<p>1、counts矩阵：包含的是整数counts;</p>
<p>2、samples数据框：包含的是文库(sample)信息。包含 lib.size列 ：for the library size (sequencing depth) for each sample,如果不自定义，  the library sizes will be computed from the column sums of the counts。其中还有一个group列，用于指定每个sample组信息</p>
<p>3、一个可选的数据框genes：gene的注释信息</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-fa83a5ee0fe58872.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>第二步： 过滤 low counts数据。</strong>与DESeq2的预过滤不同，DESeq2的预过滤只是为了改善后续运算性能，在运行过程中依旧会自动处理low count数据，edgeR需要在分析前就要排除那些low count数据，而且非常严格。从生物学角度，有生物学意义的基因的表达量必须高于某一个阈值。从统计学角度上， low count的数据不太可能有显著性差异，而且在多重试验矫正阶段还会拖后腿。 </p>
<h5 id="数据过滤"><a href="#数据过滤" class="headerlink" title="数据过滤"></a>数据过滤</h5><p>由于原来的表达量矩阵基因数太大, 可能存在某些基因根本没有表达, 因此需要预先过滤</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">&gt; keep &lt;- rowSums(cpm(<span class="symbol">y</span>)&gt;<span class="number">1</span>) &gt;= <span class="number">1</span></span><br><span class="line">&gt; <span class="symbol">y</span> &lt;- <span class="symbol">y</span>[keep, , keep.lib.sizes=FALSE]</span><br><span class="line">&gt; <span class="symbol">y</span></span><br></pre></td></tr></table></figure>
<p>这部分代码的意思指的是保留在至少在一个样本里有表达的基因(CPM &gt; 1)。 基因数就从原来的55318变为15868</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-d1f8202b26ca0a6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>###标准化<br>考虑到测序深度不同, 我们需要对其进行标准化, 避免文库大小不同导致的分析误差.</p>
<p>edgeR里默认采用TMM(trimmed mean of M-values) 对配对样本进行标准化，用到的函数是calcNormFactors</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">&gt; <span class="symbol">y</span> &lt;- calcNormFactors(<span class="symbol">y</span>)</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-8b5ece418efe7862.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="差异表达分析"><a href="#差异表达分析" class="headerlink" title="差异表达分析"></a>差异表达分析</h3><p>不同差异表达分析工具的目标就是预测出dispersion(离散值), 有了离散值就能够计算p值. 那么dispersion怎么计算呢? edgeR给了几个方法</p>
<p>根据经验给定一个值(BCV, square-root-dispersion). edgeR给的建议是, 如果你是人类数据, 且实验做的很好(无过多的其他因素影响), 设置为0.4, 如果是遗传上相似的模式物种（这里为小鼠）, 设置为0.1 （查询edgeR的bioconductor包所得）<br>Simply pick a reasonable dispersion value, based on your experience with similar data,and use that for exactTest or glmFit. Typical values for the common BCV (square-root dispersion) for datasets arising from well-controlled experiments are 0.4 for human data,0.1 for data on genetically identical model organisms or 0.01 for technical replicates.</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">&gt; y_bcv &lt;- y</span><br><span class="line"># 因为本次的数据使用的是小鼠的数据，所以使用<span class="number">0.1</span></span><br><span class="line">&gt; bcv &lt;- <span class="number">0.1</span></span><br><span class="line">&gt; et &lt;- exact<span class="constructor">Test(<span class="params">y_bcv</span>, <span class="params">dispersion</span> = <span class="params">bcv</span> ^ 2)</span></span><br><span class="line">&gt; gene1 &lt;- decide<span class="constructor">TestsDGE(<span class="params">et</span>, <span class="params">p</span>.<span class="params">value</span> = 0.05, <span class="params">lfc</span> = 0)</span></span><br><span class="line">&gt; head(gene1)</span><br><span class="line">&gt; summary(gene1)</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-d48f8e81d2527524.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>由统计结果可知，下调的基因为816个，上调的基因为572个</p>
<p>如果觉得觉得基因较多的话，可以上调bcv的值</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">&gt; y_bcv &lt;- y</span><br><span class="line">&gt; bcv &lt;- <span class="number">0.2</span></span><br><span class="line">&gt; et2 &lt;- exact<span class="constructor">Test(<span class="params">y_bcv</span>, <span class="params">dispersion</span> = <span class="params">bcv</span> ^ 2)</span></span><br><span class="line">&gt; gene2 &lt;- decide<span class="constructor">TestsDGE(<span class="params">et2</span>, <span class="params">p</span>.<span class="params">value</span> = 0.05, <span class="params">lfc</span> = 0)</span></span><br><span class="line">&gt; summary(gene2)</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-7c9c6b8d2527a3a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>由统计结果可知，下调的基因为377个，上调的基因为221个<br>与之前的结果相比，的确已经减少很多</p>
<p>将结果整理成excel表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 改一下gene1的名称</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> colnames(gene1) &lt;- <span class="string">"Signifi"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 组合将所需要的数据组成一个新的data.frame</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> results &lt;- cbind(y<span class="variable">$genes</span>,y<span class="variable">$counts</span>,et<span class="variable">$table</span>,gene1)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> head(results)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将新生成的results数据框写成一个excel数据表</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> write.csv(x = results,file = <span class="string">"C://Users/My/Desktop/DEresult.csv"</span>,row.names = F)</span></span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-15d86de730b879bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="组合成的新的data.frame表"></p>
<p>生成的excel表可以将down expressed 和 up expressed基因分开</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-1b078402234a1257.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生成的excel"></p>
<p>参考文献：<a href="https://blog.csdn.net/u012110870/article/details/102804557" target="_blank" rel="noopener">https://blog.csdn.net/u012110870/article/details/102804557</a><br><a href="https://www.bioconductor.org/packages/release/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf" target="_blank" rel="noopener">https://www.bioconductor.org/packages/release/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf</a></p>
]]></content>
      <categories>
        <category>bioinformatics</category>
      </categories>
      <tags>
        <tag>edgeR</tag>
        <tag>diﬀerential gene analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>4-RNAseq--reads count(htseq-count)与基因注释（bioMart）</title>
    <url>/2020/03/19/4-RNAseq--%E5%AF%B9RNAseq%E6%B5%8B%E5%BA%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E8%B4%A8%E9%87%8F%E6%8E%A7%E5%88%B6%EF%BC%88fastqc%EF%BC%89/</url>
    <content><![CDATA[<h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><p>在上篇的比对中，我们需要纠结是否真的需要比对，如果你只需要知道已知基因的表达情况，那么可以选择alignment-free工具（例如salmon, sailfish)，如果你需要找到noval isoforms，那么就需要alignment-based工具（如HISAT2, STAR）。到了这一篇的基因（转录本）定量，需要考虑的因素就更加多了，以至于我不知道如何说清才能理清逻辑。</p>
<p>定量分为三个水平</p>
<ul>
<li>基因水平(gene-level)</li>
<li>转录本水平(transcript-level)</li>
<li>外显子使用水平(exon-usage-level)。</li>
</ul>
<p>在<strong>基因水平</strong>上，常用的软件为HTSeq-count，featureCounts，BEDTools, Qualimap, Rsubread, GenomicRanges等。以常用的HTSeq-count为例，这些工具要解决的问题就是根据read和基因位置的overlap判断这个read到底是谁家的孩子。值得<strong>注意</strong>的是不同工具对multimapping reads处理方式也是不同的，例如HTSeq-count就直接当它们不存在。而Qualimpa则是一人一份，平均分配。</p>
<p><img src="//upload-images.jianshu.io/upload_images/2013053-b58df35852061ed0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/678/format/webp" alt="image"></p>
<p>对每个基因计数之后得到的count matrix再后续的分析中，要注意标准化的问题。如果你要比较同一个样本(within-sample)不同基因之间的表达情况，你就需要考虑到<strong>转录本长度</strong>，因为转录本越长，那么检测的片段也会更多，直接比较等于让小孩和大人进行赛跑。如果你是比较不同样本（across sample）同一个基因的表达情况，虽然不必在意转录本长度，但是你要考虑到<strong>测序深度</strong>（sequence depth)，毕竟测序深度越高，检测到的概率越大。除了这两个因素外，你还需要考虑GC%所导致的偏差，以及测序仪器的系统偏差。目前对read count标准化的算法有RPKM（SE）, FPKM（PE），TPM, TMM等，不同算法之间的差异与换算方法已经有文章进行整理和吐槽了。<strong>但是</strong>，有一些下游分析的软件会要求是输入的count matrix是原始数据，未经标准化，比如说DESeq2，这个时候你需要<strong>注意</strong>你上一步所用软件会不会进行标准化。</p>
<p>在<strong>转录本水平</strong>上，一般常用工具为Cufflinks和它的继任者StringTie， eXpress。这些软件要处理的难题就时转录本亚型（isoforms）之间通常是有重叠的，当二代测序读长低于转录本长度时，如何进行区分？这些工具大多采用的都是expectation maximization（EM）。好在我们有三代测序。</p>
<p>上述软件都是alignment-based，目前许多alignment-free软件，如kallisto, silfish, salmon，能够省去比对这一步，直接得到read count，在运行效率上更高。不过最近一篇文献[1]指出这类方法在估计丰度时存在样本特异性和读长偏差。</p>
<p>在<strong>外显子使用水平</strong>上，其实和基因水平的统计类似。但是值得注意的是为了更好的计数，我们需要提供无重叠的外显子区域的gtf文件[2]。用于分析差异外显子使用的DEXSeq提供了一个Python脚本（dexseq_prepare_annotation.py）执行这个任务。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>计数分为三个水平： gene-level, transcript-level, exon-usage-level</p>
<p>标准化方法： FPKM RPKM TMM TPM</p>
<h2 id="输出表达矩阵"><a href="#输出表达矩阵" class="headerlink" title="输出表达矩阵"></a>输出表达矩阵</h2><p>在RNA-Seq分析中，每一个基因就是一个feature（特征？），而基因被认为是它的所有外显子的和集。在可变剪切分析中，可以单独把每个外显子当作一个feature。而在ChIP-Seq分析中，feature则是预先定义的结合域。但是确定一个read到底属于哪一个feature有时会非常棘手。因此HTSeq提供了三种模式，示意图见前一幅图</p>
<ul>
<li>the union of all the sets S(i) for mode union. This mode is recommended for most use cases.</li>
<li>the intersection of all the sets S(i) for mode intersection-strict.</li>
<li>the intersection of all non-empty sets S(i) for mode intersection-nonempty.</li>
</ul>
<p>基本用法非常的简单：</p>
<blockquote>
<p>htseq-count [options] <alignment_file> <gtf_file></p>
</blockquote>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">conda install htseq</span><br><span class="line"><span class="comment"># 利用htseq-count对sort之后的bam文件进行reads计数</span></span><br><span class="line">htseq-count -r pos -f bam /home/cenhui2018/QWJ/sequence_data/<span class="number">2019103</span>0_NGS_DATA/<span class="number">19</span>R577_paired.hisat2_sorted.bam /home/cenhui2018/QWJ/sequence_data/genome/Anotation/gencode.vM23.<span class="keyword">annotation</span>.<span class="title">gtf</span> &gt; 19<span class="title">R577_paired</span>.<span class="title">count</span> 2&gt;/<span class="title">home</span>/<span class="title">cenhui2018</span>/<span class="title">QWJ</span>/<span class="title">sequence_data</span>/20191030<span class="title">_NGS_DATA</span>/19<span class="title">R577_htseq</span>.<span class="title">log</span> &amp;</span><br></pre></td></tr></table></figure>

<p>运行的时间会比较久，所以可以去了解不同参数的用法了，其中比较常用的为：</p>
<ul>
<li>-f bam/sam： 指定输入文件格式，默认SAM</li>
<li>-r name/pos: 你需要利用samtool sort对数据根据read name或者位置进行排序，默认是name</li>
<li>-s yes/no/reverse: 数据是否来自于strand-specific assay。DNA是双链的，所以需要判断到底来自于哪条链。如果选择了no， 那么每一条read都会跟正义链和反义链进行比较。默认的yes对于双端测序表示第一个read都在同一个链上，第二个read则在另一条链上。</li>
<li>-a 最低质量， 剔除低于阈值的read</li>
<li>-m 模式 union（默认）, intersection-strict and intersection-nonempty。一般而言就用默认的，作者也是这样认为的。</li>
<li>-i id attribute: 在GTF文件的最后一栏里，会有这个基因的多个命名方式（如下）， RNA-Seq数据分析常用的是gene_id， 当然你可以写一个脚本替换成其他命名方式。</li>
</ul>
<p>对count数据进行查看</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用wc指令我们可以计算count文件的行数</span></span><br><span class="line">&gt; wc -l *.<span class="built_in">count</span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-470a0a097f2c6e28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="统计count文件的行数"></p>
<p>看下每个文件的格式，</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看前4行,第一列ensembl_gene_id,第二列read_count计数</span></span><br><span class="line">&gt; $ head -n <span class="number">4</span> *.<span class="built_in">count</span>     </span><br><span class="line"> <span class="comment"># 查看后四行</span></span><br><span class="line">&gt; $ tail -n <span class="number">4</span> *.<span class="built_in">count</span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-01520ab9d5e7a426.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看count文件的首行及末行"></p>
<h4 id="合并表达矩阵并进行注释（R中进行）"><a href="#合并表达矩阵并进行注释（R中进行）" class="headerlink" title="合并表达矩阵并进行注释（R中进行）"></a>合并表达矩阵并进行注释（R中进行）</h4><p>上一步得到的2个单独的矩阵文件，现在要把这<strong>2个文件合并为行为基因名，列为样本名，中间为count的矩阵文件</strong>。</p>
<ul>
<li><h6 id="从上面看出需要至少做两步工作才能更好理解和往下进行分析"><a href="#从上面看出需要至少做两步工作才能更好理解和往下进行分析" class="headerlink" title="从上面看出需要至少做两步工作才能更好理解和往下进行分析"></a>从上面看出需要至少做两步工作才能更好理解和往下进行分析</h6></li>
</ul>
<h6 id="第一，需要把2个文件合并；"><a href="#第一，需要把2个文件合并；" class="headerlink" title="第一，需要把2个文件合并；"></a>第一，需要把2个文件合并；</h6><h6 id="第二，需要把ensembl-gene-id转换为gene-symbol-（这一步不进行也行，后面还需要）"><a href="#第二，需要把ensembl-gene-id转换为gene-symbol-（这一步不进行也行，后面还需要）" class="headerlink" title="第二，需要把ensembl_gene_id转换为gene_symbol;（这一步不进行也行，后面还需要）"></a>第二，需要把ensembl_gene_id转换为gene_symbol;（这一步不进行也行，后面还需要）</h6><ul>
<li>熟悉python的朋友可以参考<a href="https://www.jianshu.com/p/e9742bbf83b9" target="_blank" rel="noopener">这篇文章</a></li>
<li>我用R中的merge命令来处理，参考<a href="https://www.jianshu.com/p/24cf44b610a7" target="_blank" rel="noopener">这里</a>和<a href="https://www.jianshu.com/p/e9742bbf83b9" target="_blank" rel="noopener">这里</a></li>
</ul>
<p>运行R设置工作路径并查看当前目录下的文件</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line">&gt; <span class="function"><span class="title">setwd</span>(<span class="string">"/home/cenhui2018/QWJ/sequence_data/20191030_NGS_DATA/"</span>)</span></span><br><span class="line">&gt; <span class="variable">list.files</span>()</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-b70af825113864eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h6 id="1-载入数据，添加列名"><a href="#1-载入数据，添加列名" class="headerlink" title="(1) 载入数据，添加列名"></a>(1) 载入数据，添加列名</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 防止R自动把字符串string的列辨认成factor</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> options(stringAsFactor =  FALSE)  </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从19R576_paired.count文件中读取数据，并添加列名，之后生成新文件命名为control_W55</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> control_W55 &lt;- read.table(<span class="string">"19R576_paired.count"</span>,sep = <span class="string">"\t"</span>,col.names=c(<span class="string">"gene_id"</span>,<span class="string">"control_W55"</span>))</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看前6行</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> head(control_W55)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 类似的方法处理19R577_paired.count，并存储到</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> test_K54 &lt;- read.table(<span class="string">"19R577_paired.count"</span>,sep = <span class="string">"\t"</span>,col.names=c(<span class="string">"gene_id"</span>,<span class="string">"test_K54"</span>))</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-5948b355119d8bec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>######(2)数据整合<br><strong>merge进行整合</strong><br>gencode的注释文件中的gene_id（如ENSMUSG00000105298.13_3）在EBI是不能搜索到的，所以用gsub功能只保留ENSMUSG00000105298这部分<br>处理之前先看一下,也就是最后5行是我们不需要的，可以删除</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-1fa21910e16f20e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看文件的最后五行"></p>
<p>整合文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将control_w55和test_K54这两个文件通过<span class="string">"gene_id"</span>进行merge，生成新的merge好的文件raw_count</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> raw_count &lt;- merge(control_W55,test_K54, by = <span class="string">"gene_id"</span>)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看merge后的文件的前6行</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> head(raw_count)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看后六行</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> tail(raw_count)</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-04cb464c28b58a9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="合并文件并查看前六行"><br><img src="https://upload-images.jianshu.io/upload_images/3194654-3eae806f3b0f9875.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看合并后的文件的后六行"></p>
<p>######删除前5行<br>这里要注意，因为读入之后顺序变了，删除的时候看下删除的是哪些行</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&gt; raw_count_filt &lt;- raw_count[<span class="number">-1</span>:<span class="number">-5</span>,]</span><br><span class="line">&gt; head(raw_count_filt)</span><br></pre></td></tr></table></figure>
<p>删除之后的结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-52b3b3550c8494b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>######因为我们无法在EBI数据库上直接搜索找到ENSMUSG00000024045.5这样的基因，只能是ENSMUSG00000024045的整数，没有小数点，所以需要进一步替换为整数的形式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第一步通过gsub工具将匹配到的.以及后面的数字连续匹配并替换为空，并赋值给ENSEMBL</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">ENSEMBL &lt;- gsub(<span class="string">"\\.\\d*"</span>, <span class="string">""</span>, raw_count_filt<span class="variable">$gene_id</span>) </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将ENSEMBL重新添加到raw_count_filt1矩阵</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">row.names(raw_count_filt) &lt;- ENSEMBL</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看&gt;head(raw_count_filt)</span></span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-51cc729134d0ca5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可以将最后得到的raw_count_filt文件通过save()函数保存成.Rdata文件，然后复制放在自己的桌面，然后用自己的Rstudio打开</p>
<h6 id="3-对基因进行注释-获取gene-symbol"><a href="#3-对基因进行注释-获取gene-symbol" class="headerlink" title="(3) 对基因进行注释-获取gene_symbol"></a>(3) 对基因进行注释-获取gene_symbol</h6><h6 id="以下两种方式可以进行"><a href="#以下两种方式可以进行" class="headerlink" title="以下两种方式可以进行"></a>以下两种方式可以进行</h6><p>第一：去<a href="https://biodbnet-abcc.ncifcrf.gov/db/db2db.php" target="_blank" rel="noopener">这里</a>或<a href="https://www.biotools.fr/mouse/ensembl_symbol_converter" target="_blank" rel="noopener">这里</a>的网页版，输入列表即可输出，不再赘述<br>第二：用bioMart对ensembl_id转换成gene_symbol<br>bioMart包是一个连接bioMart数据库的R语言接口，能通过这个软件包自由连接到bioMart数据库</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 首先检查BioManager包是否安装</span></span><br><span class="line"><span class="keyword">if</span> (!requireNamespace(<span class="string">"BiocManager"</span>, quietly = TRUE))</span><br><span class="line">    install.packages(<span class="string">"BiocManager"</span>)</span><br><span class="line"><span class="meta"># 如果BioManager包已经安装，则通过BioManager包安装biomaRt包</span></span><br><span class="line">BiocManager::install(<span class="string">"biomaRt"</span>)</span><br><span class="line"><span class="meta"># 因为我的文件是放在桌面上的，所以先设置R的工作目录为桌面路径</span></span><br><span class="line">&gt; setwd(<span class="string">"C://Users/My/Desktop/"</span>)</span><br><span class="line"><span class="meta"># 加载放在桌面上的.Rdata文件</span></span><br><span class="line">&gt; load(<span class="string">"raw_count.Rdata"</span>)</span><br><span class="line"><span class="meta"># 加载所需要的R包</span></span><br><span class="line">&gt; library(<span class="string">'biomaRt'</span>)</span><br><span class="line">&gt; library(<span class="string">"curl"</span>)</span><br><span class="line"><span class="meta"># 用bioMart对差异表达基因进行注释</span></span><br><span class="line">&gt; mart &lt;- useDataset(<span class="string">"mmusculus_gene_ensembl"</span>, useMart(<span class="string">"ensembl"</span>))</span><br><span class="line">&gt; my_ensembl_gene_id&lt;-row.names(raw_count_filt)</span><br><span class="line">&gt; mms_symbols&lt;- getBM(attributes=c(<span class="string">'ensembl_gene_id'</span>,<span class="string">'external_gene_name'</span>,<span class="string">"description"</span>),filters = <span class="string">'ensembl_gene_id'</span>, values = my_ensembl_gene_id, mart = mart)</span><br></pre></td></tr></table></figure>
<p>执行完之后需要等待一段时间提交检索，下方会有一个进度条</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-6a199fb658862085.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>基因注释结束后，查看注释结果</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-abbae3370602ce6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基因注释结束后的结果"></p>
<p>####合并数据成一个文件</p>
<p>注意：合并的话两个数据必须有共同的列名，我们先看一下</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-216b5ca4d3e7504a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可见，两个文件没有共同的列名，所以要先给’raw_count_filt’添加一个‘ensembl_gene_id’的列名<br>方法如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将raw_count_filt的行名赋值到一个ensembl_gene_id的变量</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ensembl_gene_id&lt;-rownames(raw_count_filt)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将行名单独变成一列加到raw_count_filt文件中</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> raw_count_filt &lt;- cbind(ensembl_gene_id,raw_count_filt)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加列名</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> colnames(raw_count_filt)[1] &lt;- c(<span class="string">"ensembl_gene_id"</span>)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将raw_count_filt文件和mms_symbols文件通过ensembl_gene_id而merge在一起，生成新的文件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> diff_name&lt;-merge(raw_count_filt,mms_symbols,by=<span class="string">"ensembl_gene_id"</span>)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看新文件前6行</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> head(diff_name)</span></span><br></pre></td></tr></table></figure>
<p>代码执行结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-f1953191a5dde621.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="执行结果"></p>
<p>现在成功地生成了一个带有基因名称的count表达矩阵</p>
<p>参考链接：<br><a href="https://blog.csdn.net/lztttao/article/details/82086346" target="_blank" rel="noopener">https://blog.csdn.net/lztttao/article/details/82086346</a><br><a href="https://www.jianshu.com/p/3a0e1e3e41d0" target="_blank" rel="noopener">https://www.jianshu.com/p/3a0e1e3e41d0</a></p>
]]></content>
      <categories>
        <category>bioinformatics</category>
      </categories>
      <tags>
        <tag>htseq-count</tag>
        <tag>bioMart</tag>
      </tags>
  </entry>
  <entry>
    <title>3-RNAseq--Hisat2进行序列比对及Samtools格式转化</title>
    <url>/2020/03/19/3-RNAseq--Hisat2%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E6%AF%94%E5%AF%B9%E5%8F%8ASamtools%E6%A0%BC%E5%BC%8F%E8%BD%AC%E5%8C%96/</url>
    <content><![CDATA[<p>概况：使用处理后的fastq文件和基因组与转录组比对，确定在转录组或者基因组中的关系。在转录组和基因组的比对采取的方案不同。分别是<code>ungapped alignment to transcriptome</code>和<code>Gapped aligenment to genome</code>。 软件：<code>hisat2</code>和<code>STAR</code>在比对上都有比较好的表现。有文献显示，hisat2在纳伪较少但是弃真较多，但是速度比较快。STAR就比对而言综合质量比较好，在长短reads回帖上都有良好发挥。由于hisat2的速度优势，选择hisat2作为本次比对的软件。 在比对之前首先要先进行索引文件的获取或者制作。</p>
<h3 id="比对还是不比对"><a href="#比对还是不比对" class="headerlink" title="比对还是不比对"></a>比对还是不比对</h3><p>在比对之前，我们得了解比对的目的是什么？RNA-Seq数据比对和DNA-Seq数据比对有什么差异？<br>RNA-Seq数据分析分为很多种，比如说找差异表达基因或寻找新的可变剪切。如果找差异表达基因单纯只需要确定不同的read计数就行的话，我们可以用bowtie, bwa这类比对工具，或者是salmon这类align-free工具，并且后者的速度更快。</p>
<p>但是如果你需要找到新的isoform，或者RNA的可变剪切，看看外显子使用差异的话，你就需要TopHat, HISAT2或者是STAR这类工具用于找到剪切位点。因为RNA-Seq不同于DNA-Seq，DNA在转录成mRNA的时候会把内含子部分去掉。所以mRNA反转的cDNA如果比对不到参考序列，会被分开，重新比对一次，判断中间是否有内含子。</p>
<p><img src="upload-images.jianshu.ioupload_images2013053-61b92d51f37e74ce.jpgimageMogr2auto-orientstripimageView22w707formatwebp" alt=""></p>
<h5 id="比对工具抉择"><a href="#比对工具抉择" class="headerlink" title="比对工具抉择"></a>比对工具抉择</h5><p>在2016年的一篇综述A survey of best practices for RNA-seq data analysis，提到目前有三种RNA数据分析的策略。那个时候的工具也主要用的是TopHat,STAR和Bowtie.其中TopHat目前已经被它的作者推荐改用HISAT进行替代。</p>
<p><img src="upload-images.jianshu.ioupload_images2013053-66bff01df3f00c91.jpgimageMogr2auto-orientstripimageView22w1146formatwebp" alt=""></p>
<p>最近的Nature Communication发表了一篇题为的Gaining comprehensive biological insight into the transcriptome by performing a broad-spectrum RNA-seq analysis的文章–被称之为史上最全RNA-Seq数据分析流程，也是我一直以来想做的事情，只不过他们做的超乎我的想象。文章中在基于参考基因组的转录本分析中所用的工具，是TopHat,HISAT2和STAR，结论就是HISAT2找到junction正确率最高，但是在总数上却比TopHat和STAR少。从这里可以看出HISAT2的二类错误(纳伪）比较少，但是一类错误（弃真）就高起来。<br>就唯一比对而言，STAR是三者最佳的，主要是因为它不会像TopHat和HISAT2一样在PE比对不上的情况还强行把SE也比对到基因组上。而且在处理较长的read和较短read的不同情况，STAR的稳定性也是最佳的。<br>就速度而言，HISAT2比STAR和TopHat2平均快上2.5~100倍。</p>
<p><img src="upload-images.jianshu.ioupload_images2013053-b73988da34913dee.jpgimageMogr2auto-orientstripimageView22w998formatwebp" alt="image"></p>
<p>如果学习RNA-Seq数据分析，上面提到的两篇文献是必须要看上3遍以上的，而且建议每隔一段时间回顾一下。但是如果就比对工具而言，基本上就是HISAT2和STAR选一个就行。</p>
<h5 id="1-索引文件的获取"><a href="#1-索引文件的获取" class="headerlink" title="1. 索引文件的获取"></a>1. 索引文件的获取</h5><p>######下载index</p>
<p>首先，问自己一个问题，为什么比对的时候需要用到index？这里强烈建议大家去看Jimmy写的<a href="httpslinks.jianshu.comgoto=http%3A%2F%2Fwww.biotrainee.com%2Fthread-26-1-1.html">bowtie算法原理探究bowtie算法原理探究</a>。但是只是建议，你不需要真的去看，反正你也看不懂。</p>
<p>高通量测序遇到的第一个问题就是，成千上万甚至上几亿条read如果在合理的时间内比对到参考基因组上，并且保证错误率在接受范围内。为了提高比对速度，就需要根据参考基因组序列，经过BWT算法转换成index，而我们比对的序列其实是index的一个子集。当然转录组比对还要考虑到可变剪切的情况，所以更加复杂。</p>
<p>因此我门不是直接把read回贴到基因组上，而是把read和index进行比较。人类的index一般都是有现成的，我建议大家下载现成的，我曾经尝试过用服务器自己创建index，花的时间让我怀疑人生。<br>所以一般建议的做法就是直接从网站上下载已经index好的数据<br><img src="httpsupload-images.jianshu.ioupload_images3194654-2330547b927a9c28.pngimageMogr2auto-orientstrip%7CimageView22w1240" alt="hisat2的index"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"># 下载小鼠基因组的<span class="selector-tag">index</span></span><br><span class="line"><span class="selector-tag">mkdir</span> <span class="selector-tag">mm10_indexed</span></span><br><span class="line"><span class="selector-tag">cd</span> <span class="selector-tag">mm10_indexed</span></span><br><span class="line"># 从网站上下载安装包</span><br><span class="line"><span class="selector-tag">wget</span> <span class="selector-tag">ftpftp</span><span class="selector-class">.ccb</span><span class="selector-class">.jhu</span><span class="selector-class">.edupubinfphilohisat2datamm10</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br><span class="line">#解压</span><br><span class="line"><span class="selector-tag">tar</span> <span class="selector-tag">zvfx</span> <span class="selector-tag">mm10</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure>

<p>   不同的比对软件构建索引方式不同，所用的索引也不尽相同<br>   索引文件可以去网站下载也可以自己构建。但是索引构建会比较费时间。<a href="httpslink.zhihu.comtarget=https%3Awww.jianshu.comp250607bd401f">建立索引文件需要大约一个小时（MAC 2.6 GHz Intel Core i5 8 GB 1600 MHz DDR3）</a> 。<br>   网站下载hisat2基因组索引：<a href="httpslink.zhihu.comtarget=http%3Accb.jhu.edusoftwarehisat2index.shtml">httpccb.jhu.edusoftwarehisat2index.shtml</a><br>   本地索引文件构建参考了CSDN<a href="httpslink.zhihu.comtarget=https%3Ame.csdn.netqq_40280759">@ Richard_Jolin</a>的<a href="httpslink.zhihu.comtarget=https%3Ablog.csdn.netqq_40280759articledetails80552193">构建过程</a><br>   索引文件的格式如下，是由多个文件构成，要保证索引文件的格式和名称部分一致。</p>
<h5 id="2-hisat2的比对"><a href="#2-hisat2的比对" class="headerlink" title="2. hisat2的比对"></a>2. hisat2的比对</h5><p>使用hisat2<br>公式构建根据hisat2 的使用说明书构建了以下公式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">hisat2</span>  <span class="selector-tag">-p</span> 6    <span class="selector-tag">-x</span> <span class="selector-tag">dir</span> <span class="selector-tag">of</span> <span class="selector-tag">index</span> <span class="selector-tag">of</span> <span class="selector-tag">genome</span>  <span class="selector-tag">-1</span>  <span class="selector-tag">seq_val_1</span><span class="selector-class">.fq</span><span class="selector-class">.gz</span>   <span class="selector-tag">-2</span>  <span class="selector-tag">seq_val_2</span><span class="selector-class">.fq</span><span class="selector-class">.gz</span>  <span class="selector-tag">-S</span>  <span class="selector-tag">tem</span><span class="selector-class">.hisat2</span><span class="selector-class">.sam</span></span><br></pre></td></tr></table></figure>

<p>参数说明：<br>-p #多线程数 -x #参考基因组索引文件目录和前缀 -1 #双端测序中一端测序文件 -2 #同上 -S #输出的sam文件</p>
<p>说明：在比对过程中，hisat会自动将双端测序匹配同一reads并在基因组中比对，最后两个双端测序生成一个sam文件。比对回帖过程需要消耗大量时间和电脑运行速度和硬盘存储空间。5G左右fastq文件比对回帖过程消耗大概一个小时，生成了17G的sam格式文件。回帖完成会生成一个回帖报告。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"># 首先利用conda安装版本为<span class="number">2.1</span><span class="number">.0</span>的hisat软件</span><br><span class="line">conda install hisat2=<span class="number">2.1</span><span class="number">.0</span></span><br><span class="line">#因为比对的过程比较长，所以利用nohup命令将程序放在后台执行，并将执行结束的</span><br><span class="line">nohup homecenhui2018QWJsequence_databio_softHisat2hisat2<span class="number">-2.1</span><span class="number">.0</span>.hisat2 -p <span class="number">16</span> -x ~QWJsequence_datagenomemm10_indexedmm10genome  <span class="number">-1</span> ~QWJsequence_data20191030_NGS_DATAClean_data19R576_combined_paired_R1.fastq <span class="number">-2</span> ~QWJsequence_data20191030_NGS_DATAClean_data19R576_combined_paired_R2.fastq -S ~QWJsequence_data20191030_NGS_DATA19R576_paired.hisat2_2.sam  program_2.log <span class="number">2</span>&amp;<span class="number">1</span> &amp;</span><br></pre></td></tr></table></figure>
<p>&amp;会把任务丢到后台，所以会同时执行这3个比对程序，如果CPU和内存承受不住，去掉&amp;一个个来。比对这一步是非常消耗内存资源的，这是比对工具要将索引数据放入内存引起的。</p>
<h4 id="HISAT2输出结果"><a href="#HISAT2输出结果" class="headerlink" title="HISAT2输出结果"></a>HISAT2输出结果</h4><p>比对之后会输出如下结果</p>
<p><img src="httpsupload-images.jianshu.ioupload_images3194654-2bd31a23e5e18ff0.pngimageMogr2auto-orientstrip%7CimageView22w1240" alt=""></p>
<p>根据结果，显示的overall的比对率为97.19%</p>
<h5 id="3-SAMtools三板斧"><a href="#3-SAMtools三板斧" class="headerlink" title="3. SAMtools三板斧"></a>3. SAMtools三板斧</h5><p>SAM（sequence Alignmentmapping)数据格式是目前高通量测序中存放比对数据的标准格式，当然他可以用于存放未比对的数据。所以，<a href="httpslinks.jianshu.comgoto=https%3A%2F%2Fsamtools.github.io%2Fhts-specs%2FSAMv1.pdf">SAM</a>的格式说明</p>
<p>而目前处理SAM格式的工具主要是SAMTools，这是Heng Li大神写的.除了C语言版本，还有Java的Picard，Python的Pysam，Common lisp的cl-sam等其他版本。SAMTools的主要功能如下：</p>
<p>   view BAM-SAMSAM-BAM 转换和提取部分比对<br>   sort 比对排序<br>   merge 聚合多个排序比对<br>   index 索引排序比对<br>   faidx 建立FASTA索引，提取部分序列<br>   <a href="httpslinks.jianshu.comgoto=http%3A%2F%2Fsamtools.sourceforge.net%2Ftview.shtml">tview</a> 文本格式查看序列<br>   <a href="httpslinks.jianshu.comgoto=http%3A%2F%2Fsamtools.sourceforge.net%2Fpileup.shtml">pileup</a> 产生基于位置的结果和 <a href="httpslinks.jianshu.comgoto=http%3A%2F%2Fsamtools.sourceforge.net%2Fcns0.shtml">consensusindel calling</a></p>
<p>最常用的三板斧就是格式转换，排序，索引。而进阶教程就是看文档提高。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"># 利用<span class="selector-tag">samtools</span>工具将比对得到的<span class="selector-tag">sam</span>文件转换为<span class="selector-tag">bam</span>文件</span><br><span class="line"><span class="selector-tag">samtools</span> <span class="selector-tag">view</span> <span class="selector-tag">-S</span> 19<span class="selector-tag">R576_paired</span><span class="selector-class">.hisat2_2</span><span class="selector-class">.sam</span> <span class="selector-tag">-b</span>  19<span class="selector-tag">R576_paired</span><span class="selector-class">.hisat2_2</span><span class="selector-class">.bam</span> &amp;</span><br><span class="line"># 将得到的<span class="selector-tag">sam</span>文件<span class="selector-tag">sort</span>一下</span><br><span class="line"><span class="selector-tag">samtools</span> <span class="selector-tag">sort</span> 19<span class="selector-tag">R576_paired</span><span class="selector-class">.hisat2_2</span><span class="selector-class">.bam</span> <span class="selector-tag">-o</span> 19<span class="selector-tag">R576_paired</span><span class="selector-class">.hisat2_2_sorted</span><span class="selector-class">.bam</span></span><br><span class="line">#将得到的<span class="selector-tag">sort</span>之后的<span class="selector-tag">bam</span>文件排序</span><br><span class="line"><span class="selector-tag">samtools</span> <span class="selector-tag">index</span> 19<span class="selector-tag">R576_paired</span><span class="selector-class">.hisat2_2_sorted</span><span class="selector-class">.bam</span> &amp;</span><br></pre></td></tr></table></figure>

<h5 id="4-IGV查看"><a href="#4-IGV查看" class="headerlink" title="4. IGV查看"></a>4. IGV查看</h5><p>这个<code>seq_sourted.bam</code>文件可以通过<code>samtools</code>或者<a href="httpslink.zhihu.comtarget=http%3Awww.igv.org">IGV( Integrative Genomics Viewer)</a>独立软件进行查看。在IGV软件中载入<code>seq_sourted.bam</code>文件。 可以很直观清晰地观察到reads在基因组中的回帖情况和外显子与内含子的关系。</p>
<p><img src="httpsupload-images.jianshu.ioupload_images3194654-9b6cbe4639545939.pngimageMogr2auto-orientstrip%7CimageView22w1240" alt="IGV查看结果"></p>
<p>参考文献：<br><a href="httpszhuanlan.zhihu.comp61847802">httpszhuanlan.zhihu.comp61847802</a><br><a href="httpswww.jianshu.comp681e02e7f9af">httpswww.jianshu.comp681e02e7f9af</a></p>
]]></content>
      <categories>
        <category>bioinformatics</category>
      </categories>
      <tags>
        <tag>hesat2</tag>
        <tag>alignment</tag>
        <tag>samtools</tag>
      </tags>
  </entry>
  <entry>
    <title>2-RNAseq--对RNAseq测序数据质量控制（fastqc）</title>
    <url>/2020/03/19/2-RNAseq--%E5%AF%B9RNAseq%E6%B5%8B%E5%BA%8F%E6%95%B0%E6%8D%AE%E8%B4%A8%E9%87%8F%E6%8E%A7%E5%88%B6%EF%BC%88fastqc%EF%BC%89/</url>
    <content><![CDATA[<h2 id="质量汇报生成与读取"><a href="#质量汇报生成与读取" class="headerlink" title="质量汇报生成与读取"></a>质量汇报生成与读取</h2><h3 id="fastq质量汇报"><a href="#fastq质量汇报" class="headerlink" title="fastq质量汇报"></a>fastq质量汇报</h3><p>使用命令<code>fastqc -o &lt;output dir&gt; &lt;seqfile1,seqfile2..&gt;</code>来进行质量报告。</p>
 <figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"># 下载fastqc工具包</span><br><span class="line">$ wget https:<span class="comment">//www.bioinformatics.babraham.ac.uk/projects/fastqc/fastqc_v0.11.8.zip</span></span><br><span class="line"># 解压</span><br><span class="line">&amp; unzip fastqc_v0.<span class="number">11.8</span>.zip</span><br><span class="line"># 执行fastqc</span><br><span class="line">&amp; ~FastQC<span class="regexp">/./</span>fastqc -f fastq -o <span class="regexp">/home/</span>cenhui2018<span class="regexp">/QWJ/</span>sequence_data<span class="regexp">/20191030_NGS_DATA/</span>result <span class="regexp">/home/</span>cenhui2018<span class="regexp">/QWJ/</span>sequence_data<span class="regexp">/20191030_NGS_DATA/</span><span class="number">19</span>R576_combined_R1.fastq</span><br></pre></td></tr></table></figure>
<p>需要注意的是./fastqc前面的”.”不可以省略</p>
<p>每个fastqc文件会获得一个质量分析报告，来描述此次RNA-seq的测序质量。 获取质量报告如图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-963d416408466a62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Fastqc basic information"></p>
<h5 id="Basic-Statistics"><a href="#Basic-Statistics" class="headerlink" title="Basic Statistics"></a>Basic Statistics</h5><p>从read水平来总览，判断测序质量。 Encoding ：测序平台的版本，因为不同版本的 error p的计算方法不一样。 Total sequence：测序深度。一共测序的read数。是质量分析的主要参数。 Sequence length：测序长度。 %GC：GC碱基含量比，一般是物种特异性，比如人类是42%左右。</p>
<h5 id="Perbase-sequence-quality"><a href="#Perbase-sequence-quality" class="headerlink" title="Perbase sequence quality"></a>Perbase sequence quality</h5><p>横坐标： 第1-100个测序得到的碱基 纵坐标： 测序质量评估。这里的Q=-10*lg10(error P),即20%代表1%的错误读取率，30%代表0.1%的错误读取率 箱型图： 红色线，是某个顺序下测序碱基所有测序质量的中位数。黄色块，是测序质量在25%-75%区域。蓝色线，平均数。 一般要求： 测序箱型图10%的线大于Q=20。Q20过滤法。</p>
<h5 id="per-tail-sequence-quality"><a href="#per-tail-sequence-quality" class="headerlink" title="per tail sequence quality"></a>per tail sequence quality</h5><p>横坐标：同上。 纵坐标：tail的index编号。 目的：防止测序过程中某些tail受不可控因素测序质量低。 标准：蓝色表示质量高，浅色或暖色表示质量低，后续的分析可以去除低质量tail。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-95c486f10220c207.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="per tail sequence quality"></p>
<h5 id="Per-sequence-quality-scores"><a href="#Per-sequence-quality-scores" class="headerlink" title="Per sequence quality scores"></a>Per sequence quality scores</h5><p>从read的总体测序质量分布来判定此次的测序质量，是质量分析的重要标准之一。 横坐标：表示read的测序质量Q=-10*lg10(error P)。 纵坐标：表示在该Q值下的read 的数量 标准：需要集中在高分区</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-2711614ef1a63dfe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Per sequence quality scores"></p>
<h5 id="Per-base-sequence-content"><a href="#Per-base-sequence-content" class="headerlink" title="Per base sequence content"></a>Per base sequence content</h5><p>横坐标：1-100的测序碱基位置 纵坐标：碱基百分比 标准：理论上，ATCG碱基的分布应该差别不大，即四条线应该大致平行状态。如果AT或CG差异超过10%，此项检测是危险的。一般是测序机器前几个碱基测序时候因为状态调整导致测序略有偏差，如果前几个碱基偏差较大，可以在后期将前几个碱基切掉。造成这个偏差较大的原因重要是由于测序数据中的adapter没有clean干净。所以在接下来的数据处理中需要对测序数据进行clean data的处理，下一个章节会详细介绍clean data的步骤。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-a5a49a0ef6ebbca5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Per base sequence content"></p>
<h5 id="Sequence-Length-Distribution"><a href="#Sequence-Length-Distribution" class="headerlink" title="Sequence Length Distribution"></a>Sequence Length Distribution</h5><p>统计read的碱基长度，本例理论上测序应该全是150bp。 横坐标：是read的碱基长度 纵坐标：是该长度下的read数量</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-758ed1c39abb493c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Sequence Length Distribution"></p>
<h5 id="Per-sequence-GC-content"><a href="#Per-sequence-GC-content" class="headerlink" title="Per sequence GC content"></a>Per sequence GC content</h5><p>横坐标：每个read的平局GC含量占比 纵坐标：一定GC比下的read数 标准：蓝色是理论值，红色是真实值。两者接近是比较好的状态。如果有双峰，可能混有了其他物种的DNA序列。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-3777a0a933d6ea7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Per sequence GC content"></p>
<h5 id="Adapter-Content"><a href="#Adapter-Content" class="headerlink" title="Adapter Content"></a>Adapter Content</h5><p>一般测序在初步生成fastq文件时候，adapter会被去除，但是有的会没有去除或者遗漏部分adapter。所以这一步是检测RNA-seq测序过程中adapter是否去除。如果没有去除会严重影响后续的比对工作。没有去除的adapter在质量处理环节会被处理掉。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-46b7f01bc01e0b09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Adapter Content"></p>
<ol start="2">
<li>multiqc质量报告<br>multiqc可以对几个fastqc报告文件进行总结并汇总到一个报告文件中，以更直观到防止展示。使用方法</li>
</ol>
<blockquote>
<p>multiqc <analysis directory></p>
</blockquote>
<p>参考链接：<br><a href="https://zhuanlan.zhihu.com/p/61847802" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/61847802</a></p>
]]></content>
      <tags>
        <tag>fastqc</tag>
        <tag>fastc</tag>
      </tags>
  </entry>
  <entry>
    <title>1-RNAseq--测序原始数据处理（Clean  data）</title>
    <url>/2020/03/16/1-RNAseq--%E6%B5%8B%E5%BA%8F%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%EF%BC%88Clean%20%20data%EF%BC%89/</url>
    <content><![CDATA[<h1 id="fastq文件"><a href="#fastq文件" class="headerlink" title="fastq文件"></a>fastq文件</h1><p>一般我们从公司里得到的原始测序数据都是属于fastq.gz文件, .gz是一种压缩格式的缩写，于是首先第一步是对这些压缩格式进行解压操作<br><img src="https://upload-images.jianshu.io/upload_images/3194654-6c7f1ae724836c1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">gzip</span> <span class="selector-tag">-d</span> 19<span class="selector-tag">R576_combined_R1</span><span class="selector-class">.fastq</span><span class="selector-class">.gz</span> 19<span class="selector-tag">R576_combined_R2</span><span class="selector-class">.fastq</span><span class="selector-class">.gz</span> 19<span class="selector-tag">R577_combined_R1</span><span class="selector-class">.fastq</span><span class="selector-class">.gz</span> 19<span class="selector-tag">R577_combined_R2</span><span class="selector-class">.fastq</span><span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure>
<p>解压好的文件即正常的Fastq文件，当然这里只是演示一下Fastq.gz是怎样解压的，给大家看一下即可，建议还是暂时不用解压，以为后面将介绍的测序质控还是用的压缩格式的gz文件作为输入文件<br><img src="https://upload-images.jianshu.io/upload_images/3194654-0960d9117ba7b837.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>首先先简单介绍一下什么是fataq文件</p>
<p>在illumina的测序文件中，采用双端测序（paired-end），一个样本得到的是seq_1.fastq.gz和seq_2.fastq.gz两个文件，每个文件存放一段测序文件。在illumina的测序的cDNA短链被修饰为以下形式（图源见水印）：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-34575c8f297fc99e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>两端的序列是保护碱基（terminal sequence）、接头序列（adapter）、索引序列（index）、引物结合位点（Primer Binding Site）：其中 adapter是和flowcell上的接头互补配对结合的；index是一段特异序列，加入index是为了提高illumina测序仪的使用率，因为同一个泳道可能会测序多个样品，样品间的区分就是通过index区分。参考：<a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/hanli1992/article/details/82980042">illumina 双端测序（pair end）</a>、<a href="https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/b18ee79a0285">双端测序中read1和read2的关系</a>。</p>
<p>在illumina公司测得的序列文件经过处理以fastq文件协议存储为*.fastq格式文件。在fastq文件中每4行存储一个read。</p>
<p><strong>第一行</strong>：以@开头接ReadID和其他信息，分别介绍了 <strong>第二行</strong>：read测序信息 <strong>第三行</strong>：规定必须以“+”开头，后面跟着可选的ID标识符和可选的描述内容，如果“+”后面有内容，该内容必须与第一行“@”后的内容相同 <strong>第四行</strong>：每个碱基的质量得分。记分方法是利用ERROR P经过对数和运算分为40个级别分别与ASCII码的第33号<code>!</code>和第73号<code>I</code>对应。用ASCII码表示碱基质量是为了减少文件空间占据和防止移码导致的数据损失。fastq文件预览如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-3a962a7125288d55.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h1 id="对数据进行质控（去接头和低质量的reads以及Fastqc）"><a href="#对数据进行质控（去接头和低质量的reads以及Fastqc）" class="headerlink" title="对数据进行质控（去接头和低质量的reads以及Fastqc）"></a>对数据进行质控（去接头和低质量的reads以及Fastqc）</h1><p>为什么要对数据进行clean data这一步呢，主要是在测序过程中加入了接头序列（便于测序），以及测序过程中产生的一些低质量的reads, 如果不事先对这些进行筛选的很有可能会影响之后进行序列比对。</p>
<p>这里给大家介绍的就是数据质控界常用的——Trimmomatic软件。</p>
<h2 id="Trimmomatic-简介"><a href="#Trimmomatic-简介" class="headerlink" title="Trimmomatic 简介"></a>Trimmomatic 简介</h2><p>Trimmomatic软件，2014年首次发表在Bioinformatics期刊上，是一款专门对Illumina平台测序产生的reads进行修剪和过滤的软件。自发表以来，Trimmomatic软件凭借其简单的安装方法、较快的运行速度（支持多线程）、强大的去接头能力（simple和palindrome两种模式）、多元化的低质量数据处理方式、人性化的输出格式（clean reads为一一对应的pair-end形式，无需再次处理）等特点，深受数据处理者喜爱！下面就由小奥带大家一起来学习下Trimmomatic的具体用法。</p>
<h3 id="Trimmomatic-下载"><a href="#Trimmomatic-下载" class="headerlink" title="Trimmomatic 下载"></a>Trimmomatic 下载</h3><h4 id="一-在Linux系统下通过命令行进行下载安装"><a href="#一-在Linux系统下通过命令行进行下载安装" class="headerlink" title="(一)在Linux系统下通过命令行进行下载安装"></a>(一)在Linux系统下通过命令行进行下载安装</h4><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 创建一个名为Trimmomatic的文件夹</span></span><br><span class="line"></span><br><span class="line">mkdir Trimmomatic</span><br><span class="line"></span><br><span class="line"><span class="meta"># 进入Trimmomatic文件夹工作路径下</span></span><br><span class="line"></span><br><span class="line">cd Trimmomatic</span><br><span class="line"></span><br><span class="line"><span class="meta"># 通过wget命令下载Trimmomatic-0.38.zip压缩文件</span></span><br><span class="line"></span><br><span class="line">wget http:<span class="comment">//www.usadellab.org/cms/uploads/supplementary/Trimmomatic/Trimmomatic-0.38.zip</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#uzip解压缩Trimmomatic-0.36.zip文件</span></span><br><span class="line"></span><br><span class="line">unzip Trimmomatic<span class="number">-0.38</span>.</span><br><span class="line"></span><br><span class="line"><span class="meta">#运行安装命令，即可完成安装</span></span><br><span class="line"></span><br><span class="line">java -jar~/biosoft/Trimmomatic/Trimmomatic<span class="number">-0.36</span>/trimmomatic<span class="number">-0.36</span>.jar –h</span><br></pre></td></tr></table></figure>
<h5 id="二-通过conda直接一键安装"><a href="#二-通过conda直接一键安装" class="headerlink" title="(二)通过conda直接一键安装"></a>(二)通过conda直接一键安装</h5><p>先search一下到底conda可不可以搜索到软件安装的channel</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">conda search trimmomatic</span></span><br></pre></td></tr></table></figure>

<p>反馈显示可以从相应的channel中找到trimmomatic软件<br>于是直接用conda一键安装</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">conda <span class="keyword">install</span> trimmomatic</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-88c5b49855d0817a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>安装完成</p>
<h3 id="Trimmomatic-质控用法"><a href="#Trimmomatic-质控用法" class="headerlink" title="Trimmomatic 质控用法"></a>Trimmomatic 质控用法</h3><p>根据单端测序和双端测序两种模式，Trimmomatic软件也有两种质控用法</p>
<h5 id="◆-1-SE-模式"><a href="#◆-1-SE-模式" class="headerlink" title="◆ 1. SE 模式"></a>◆ 1. SE 模式</h5><p>SE模式下，只有一个输入文件和一个质控后的输出文件，运行命令如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Java –jar <span class="tag">&lt; <span class="attr">trimmomatic</span>的安装路径&gt;</span> SE –threads <span class="tag">&lt;<span class="name">线程数</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span>&gt;</span> <span class="tag">&lt;<span class="name">output</span>&gt;</span> <span class="tag">&lt;<span class="name">step1</span>&gt;</span> <span class="tag">&lt;<span class="name">step2</span>&gt;</span> …<span class="tag">&lt;<span class="name">step1</span>&gt;</span><span class="tag">&lt;<span class="name">step2</span>&gt;</span>… 表示每一步的质控参数</span><br></pre></td></tr></table></figure>
<h5 id="◆-2-PE模式"><a href="#◆-2-PE模式" class="headerlink" title="◆ 2. PE模式"></a>◆ 2. PE模式</h5><p>PE 模式下，有两个输入文件（正向测序reads和反向测序reads）和四个质控后的输出文件（双端序列都保留的paired序列文件和只保留一端序列的unpaired序列文件），运行命令如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">java -jar <span class="variable">$trimmomatic</span> PE -threads <span class="number">12</span> -phred33 <span class="variable">$R1</span><span class="selector-class">.fq</span><span class="selector-class">.gz</span> <span class="variable">$R2</span><span class="selector-class">.fq</span><span class="selector-class">.gz</span> <span class="variable">$R1</span><span class="selector-class">.paired</span><span class="selector-class">.fq</span><span class="selector-class">.gz</span> <span class="variable">$R1</span><span class="selector-class">.unpaired</span><span class="selector-class">.fq</span><span class="selector-class">.gz</span> <span class="variable">$R2</span><span class="selector-class">.paired</span><span class="selector-class">.fq</span><span class="selector-class">.gz</span> <span class="variable">$R2</span><span class="selector-class">.unpaired</span><span class="selector-class">.fq</span><span class="selector-class">.gz</span> ILLUMINACLIP:<span class="variable">$adapter</span><span class="selector-class">.fa</span>:<span class="number">2</span>:<span class="number">30</span>:<span class="number">10</span> LEADING:<span class="number">3</span> TRAILING:<span class="number">3</span> SLIDINGWINDOW:<span class="number">4</span>:<span class="number">15</span> MINLEN:<span class="number">36</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数设置说明（同一个命令下的不同参数可以用“：”来界定）：<br>$ 表示软件或文件所在的路径（建议使用绝对路径）<br> 其中<strong>R1.fq.gz</strong>以及 <strong>R2.fq.gz</strong> 为两个输入文件<br><strong>R1.paired.fq.gz</strong> 、<strong>R1.unpaired.fq.gz</strong>、 <strong>R2.paired.fq.gz</strong> 、<strong>R2.unpaired.fq.gz</strong> 为四个对应的输出文件<br>Phred33 设置碱基的质量格式，默认的是-phred64。</p>
</blockquote>
<blockquote>
<p>ILLUMINACLIP:$adapter.fa:2:30:10 adapter.fa为接头文件，2表示最大mismatch数，30表示palindrome模式下碱基的匹配阈值，10表示simple模式下碱基的匹配阈值。<br>LEADING: 3 表示切除reads 5’端碱基质量低于3的碱基。<br>TRAILING:3 表示切除3’ 端碱基质量低于3的碱基。<br>SLIDINGWINDOW:4:15 表示以4个碱基为窗口进行滑动，切除窗口内碱基平均质量小于15的。<br>MINLEN:36 丢弃以上步骤处理后，序列长度小于36的reads。</p>
</blockquote>
<p>运行代码如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">trimmomatic PE -threads <span class="number">12</span> -phred33 /mnt/e/sequence_data_YNY/<span class="number">20191030</span>_NGS_DATA/<span class="number">19</span>R576_combined_R1.fastq.gz  /mnt/e/sequence_data_YNY/<span class="number">20191030</span>_NGS_DATA/<span class="number">19</span>R576_combined_R2.fastq.gz  /mnt/e/sequence_data_YNY/<span class="number">20191030</span>_NGS_DATA/<span class="number">19</span>R576_combined_R1.paired.fq.gz /mnt/e/sequence_data_YNY/<span class="number">20191030</span>_NGS_DATA/<span class="number">19</span>R576_c</span><br><span class="line">ombined_R1.unpaired.fq.gz /mnt/e/sequence_data_YNY/<span class="number">20191030</span>_NGS_DATA/<span class="number">19</span>R576_combined_R2.paired.fq.gz /mnt/e/sequence_data_YNY/<span class="number">20191030</span>_NGS_DATA/<span class="number">19</span>R576_combined_R2.unpaired.fq.gz ILLUMINACLI</span><br><span class="line">P:$adapter.fa:<span class="number">2</span>:<span class="number">30</span>:<span class="number">10</span> LEADING:<span class="number">3</span> TRAILING:<span class="number">3</span> SLIDINGWINDOW:<span class="number">4</span>:<span class="number">15</span> MINLEN:<span class="number">36</span> ; trimmomatic PE -threads <span class="number">12</span> -phred33 /mnt/e/sequence_data_YNY/<span class="number">20191030</span>_NGS_DATA/<span class="number">19</span>R577_combined_R1.fastq.gz  /mnt/e/</span><br><span class="line">sequence_data_YNY/<span class="number">20191030</span>_NGS_DATA/<span class="number">19</span>R577_combined_R2.fastq.gz  /mnt/e/sequence_data_YNY/<span class="number">20191030</span>_NGS_DATA/<span class="number">19</span>R577_combined_R1.paired.fq.gz /mnt/e/sequence_data_YNY/<span class="number">20191030</span>_NGS_DATA/<span class="number">19</span>R577</span><br><span class="line">_combined_R1.unpaired.fq.gz /mnt/e/sequence_data_YNY/<span class="number">20191030</span>_NGS_DATA/<span class="number">19</span>R577_combined_R2.paired.fq.gz /mnt/e/sequence_data_YNY/<span class="number">20191030</span>_NGS_DATA/<span class="number">19</span>R577_combined_R2.unpaired.fq.gz ILLUMINAC</span><br><span class="line">LIP:$adapter.fa:<span class="number">2</span>:<span class="number">30</span>:<span class="number">10</span> LEADING:<span class="number">3</span> TRAILING:<span class="number">3</span> SLIDINGWINDOW:<span class="number">4</span>:<span class="number">15</span> MINLEN:<span class="number">36</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/3194654-b32de3de66fa88f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="开始执行去接头"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-df2d26db48586472.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结束"></p>
<p>最终运行出的结果输出文件有四个，R1.paired.fq.gz 、R1.unpaired.fq.gz、 R2.paired.fq.gz 、R2.unpaired.fq.gz ，如果在接下来要进行序列比对的话用的文件只需要使用到两个paired文件。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-7162d46bf4432054.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输出结果"></p>
<p>到这里，我们的RNAseq流程中的原始数据处理(clean data)这一步就已经到这里就告一段落了。</p>
<h1 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h1><p><a href="https://www.sohu.com/a/252244330_100269283" target="_blank" rel="noopener">https://www.sohu.com/a/252244330_100269283</a><br><a href="https://zhuanlan.zhihu.com/p/61847802" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/61847802</a></p>
]]></content>
      <categories>
        <category>RNA-seq</category>
      </categories>
      <tags>
        <tag>bioinformatics</tag>
        <tag>fastq</tag>
        <tag>fastqc</tag>
        <tag>Trimmomatic</tag>
      </tags>
  </entry>
  <entry>
    <title>Conda的安装与使用</title>
    <url>/2020/03/15/conda%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="conda简介"><a href="#conda简介" class="headerlink" title="conda简介"></a>conda简介</h2><p>Conda 是一个开源的软件包管理系统和环境管理系统，用于安装多个版本的软件包及其依赖关系，并在它们之间轻松切换。 Conda 是为 Python 程序创建的，适用于 Linux，OS X 和Windows，也可以打包和分发其他软件。</p>
<h2 id="安装conda"><a href="#安装conda" class="headerlink" title="安装conda"></a>安装conda</h2><p>conda分为anaconda和miniconda。anaconda是包含一些常用包的版本（这里的常用不代表你常用），miniconda则是精简版，需要啥装啥，所以推荐使用miniconda。</p>
<h3 id="下载网址"><a href="#下载网址" class="headerlink" title="下载网址"></a>下载网址</h3><blockquote>
<p>conda官网：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fconda.io%2Fminiconda.html" target="_blank" rel="noopener">https://conda.io/miniconda.html</a></p>
</blockquote>
<p>选择适合自己的版本，用wget命令下载。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">wget -c https:<span class="regexp">//</span>repo.continuum.io<span class="regexp">/miniconda/</span>Miniconda3-latest-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>


<p>安装命令：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">chmod <span class="number">777</span> Miniconda3-latest-Linux-x86_64.<span class="keyword">sh </span><span class="comment">#给执行权限</span></span><br><span class="line"><span class="keyword">bash </span>Miniconda3-latest-Linux-x86_64.<span class="keyword">sh </span><span class="comment">#运行</span></span><br></pre></td></tr></table></figure>

<p>一路yes，安装成功</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-57b420a278cb4375.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="安装完成"></p>
<h4 id="激活conda"><a href="#激活conda" class="headerlink" title="激活conda"></a>激活conda</h4><p>找到你刚才安装的miniconda，如果没有更改过安装位置的话应该是在/home下面，cd到miniconda3的bin目录下面，能看到有一个activate</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-3f719b7cac69dff4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>给activate添加一下权限才能使用</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">#添加权限</span></span><br><span class="line">chmod <span class="number">777</span> <span class="built_in">activate</span></span><br></pre></td></tr></table></figure>
<p>接下来启动conda</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">. <span class="string">./active</span></span><br><span class="line"><span class="comment">#这两个点不是连在一起的</span></span><br></pre></td></tr></table></figure>
<p>需要注意一下的是/active前面的两个点之间不是连着一起的.<br>需要分开，其实这条命令也相当于source ./active</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-af308489c6e4e201.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>当命令行前面出现(base)的时候说明现在已经在conda的环境中了。这时候输入conda list 命令就有反应了</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">conda <span class="built_in">list</span></span><br></pre></td></tr></table></figure>
<p>以下是输入conda list 显示的结果</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-f865da90bdd4d2f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="conda list"></p>
<h2 id="利用conda安装生物信息软件"><a href="#利用conda安装生物信息软件" class="headerlink" title="利用conda安装生物信息软件"></a>利用conda安装生物信息软件</h2><h3 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令:"></a>安装命令:</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">conda <span class="keyword">install</span> samtools</span><br></pre></td></tr></table></figure>

<h3 id="搜索需要的安装包"><a href="#搜索需要的安装包" class="headerlink" title="搜索需要的安装包:"></a>搜索需要的安装包:</h3><p>提供一个网址,用于事先查找想安装的软件存不存在<br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fbioconda.github.io%2Frecipes" target="_blank" rel="noopener">conda available packages</a></p>
<p>当然, 也可以用这个命令进行搜索</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">conda search samtools</span></span><br></pre></td></tr></table></figure>
<p>提示错误，PackagesNotFoundError: The following packages are not available from current channels:，主要是没有为conda添加相应的下载软件安装包的channel</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-2bd50709bc07e4a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>添加生物信息分析常用的channel，添加的是清华的镜像channel</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">conda config --add channels https:<span class="regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="regexp">/anaconda/</span>pkgs<span class="regexp">/free/</span></span><br><span class="line">conda config --add channels https:<span class="regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="regexp">/anaconda/</span>pkgs<span class="regexp">/main/</span></span><br><span class="line">conda config --add channels https:<span class="regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="regexp">/anaconda/</span>cloud<span class="regexp">/conda-forge/</span></span><br><span class="line">conda config --add channels https:<span class="regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="regexp">/anaconda/</span>cloud<span class="regexp">/bioconda/</span></span><br></pre></td></tr></table></figure>
<p>另外对channel常用的操作</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">显示安装的频道</span><br><span class="line"> conda<span class="built_in"> config </span>--<span class="builtin-name">set</span> show_channel_urls <span class="literal">yes</span> </span><br><span class="line"></span><br><span class="line">查看已经添加的channels</span><br><span class="line">conda<span class="built_in"> config </span>--<span class="builtin-name">get</span> channels</span><br><span class="line"></span><br><span class="line">已添加的channel在哪里查看</span><br><span class="line">vim ~/.condarc</span><br></pre></td></tr></table></figure>


<p>添加完channel之后继续下载</p>
<p>利用conda安装生物信息软件</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">conda <span class="keyword">install</span> samtools</span><br></pre></td></tr></table></figure>

<p>提示安装进程，显示安装完成</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-e948bc90562938d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>安装完成后，可以用“which 软件名”来查看该软件安装的位置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">which</span> samtools</span><br></pre></td></tr></table></figure>
<p>显示samtools的安装路径</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3194654-9ea2152bf864bc9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>搜索目前软件包有哪几个版本</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">conda search samtools</span></span><br></pre></td></tr></table></figure>


<p><img src="https://upload-images.jianshu.io/upload_images/3194654-995dd905543db1f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>如需要安装特定的版本:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">conda</span> <span class="string">install 软件名=版本号</span></span><br><span class="line"><span class="attr">conda</span> <span class="string">samtools=1.10</span></span><br></pre></td></tr></table></figure>
<p>这时conda会先卸载已安装版本，然后重新安装指定版本。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">查看已安装软件:</span><br><span class="line">conda <span class="built_in">list</span></span><br></pre></td></tr></table></figure>


<p>更新指定软件:</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">conda update samtools</span></span><br></pre></td></tr></table></figure>

<p>卸载指定软件:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">conda <span class="builtin-name">remove</span> gatk</span><br></pre></td></tr></table></figure>

<p>退出conda环境<br>退出也很简单，之前我们是. ./activate 或者 (. ~/miniconda3/bin/activate)现在退出只要:</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">. </span>./deactivate</span><br></pre></td></tr></table></figure>
<p>就退出当前的环境了</p>
<p><a href="https://www.jianshu.com/p/edaa744ea47d" target="_blank" rel="noopener">参考链接</a></p>
]]></content>
      <categories>
        <category>RNA-seq</category>
      </categories>
      <tags>
        <tag>bioinformatics</tag>
        <tag>conda</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/15/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
